// Generated by ProtoGen, Version=2.4.1.521, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace KRPC.Schema.Control {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class Control {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    internal static pbd::MessageDescriptor internal__static_Control_Controls__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::KRPC.Schema.Control.Controls, global::KRPC.Schema.Control.Controls.Builder> internal__static_Control_Controls__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Control_CurrentStage__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::KRPC.Schema.Control.CurrentStage, global::KRPC.Schema.Control.CurrentStage.Builder> internal__static_Control_CurrentStage__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;
    
    static Control() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          "Cg1Db250cm9sLnByb3RvEgdDb250cm9sIoEBCghDb250cm9scxIQCgh0aHJv" + 
          "dHRsZRgBIAEoAhINCgVwaXRjaBgCIAEoAhILCgN5YXcYAyABKAISDAoEcm9s" + 
          "bBgEIAEoAhIJCgF4GAUgASgCEgkKAXkYBiABKAISCQoBehgHIAEoAhILCgNz" + 
          "YXMYCCABKAgSCwoDcmNzGAkgASgIIh0KDEN1cnJlbnRTdGFnZRINCgVzdGFn" + 
          "ZRgBIAIoDQ==");
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_Control_Controls__Descriptor = Descriptor.MessageTypes[0];
        internal__static_Control_Controls__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::KRPC.Schema.Control.Controls, global::KRPC.Schema.Control.Controls.Builder>(internal__static_Control_Controls__Descriptor,
                new string[] { "Throttle", "Pitch", "Yaw", "Roll", "X", "Y", "Z", "Sas", "Rcs", });
        internal__static_Control_CurrentStage__Descriptor = Descriptor.MessageTypes[1];
        internal__static_Control_CurrentStage__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::KRPC.Schema.Control.CurrentStage, global::KRPC.Schema.Control.CurrentStage.Builder>(internal__static_Control_CurrentStage__Descriptor,
                new string[] { "Stage", });
        return null;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          }, assigner);
    }
    #endregion
    
  }
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Controls : pb::GeneratedMessage<Controls, Controls.Builder> {
    private Controls() { }
    private static readonly Controls defaultInstance = new Controls().MakeReadOnly();
    private static readonly string[] _controlsFieldNames = new string[] { "pitch", "rcs", "roll", "sas", "throttle", "x", "y", "yaw", "z" };
    private static readonly uint[] _controlsFieldTags = new uint[] { 21, 72, 37, 64, 13, 45, 53, 29, 61 };
    public static Controls DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Controls DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Controls ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::KRPC.Schema.Control.Control.internal__static_Control_Controls__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Controls, Controls.Builder> InternalFieldAccessors {
      get { return global::KRPC.Schema.Control.Control.internal__static_Control_Controls__FieldAccessorTable; }
    }
    
    public const int ThrottleFieldNumber = 1;
    private bool hasThrottle;
    private float throttle_;
    public bool HasThrottle {
      get { return hasThrottle; }
    }
    public float Throttle {
      get { return throttle_; }
    }
    
    public const int PitchFieldNumber = 2;
    private bool hasPitch;
    private float pitch_;
    public bool HasPitch {
      get { return hasPitch; }
    }
    public float Pitch {
      get { return pitch_; }
    }
    
    public const int YawFieldNumber = 3;
    private bool hasYaw;
    private float yaw_;
    public bool HasYaw {
      get { return hasYaw; }
    }
    public float Yaw {
      get { return yaw_; }
    }
    
    public const int RollFieldNumber = 4;
    private bool hasRoll;
    private float roll_;
    public bool HasRoll {
      get { return hasRoll; }
    }
    public float Roll {
      get { return roll_; }
    }
    
    public const int XFieldNumber = 5;
    private bool hasX;
    private float x_;
    public bool HasX {
      get { return hasX; }
    }
    public float X {
      get { return x_; }
    }
    
    public const int YFieldNumber = 6;
    private bool hasY;
    private float y_;
    public bool HasY {
      get { return hasY; }
    }
    public float Y {
      get { return y_; }
    }
    
    public const int ZFieldNumber = 7;
    private bool hasZ;
    private float z_;
    public bool HasZ {
      get { return hasZ; }
    }
    public float Z {
      get { return z_; }
    }
    
    public const int SasFieldNumber = 8;
    private bool hasSas;
    private bool sas_;
    public bool HasSas {
      get { return hasSas; }
    }
    public bool Sas {
      get { return sas_; }
    }
    
    public const int RcsFieldNumber = 9;
    private bool hasRcs;
    private bool rcs_;
    public bool HasRcs {
      get { return hasRcs; }
    }
    public bool Rcs {
      get { return rcs_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _controlsFieldNames;
      if (hasThrottle) {
        output.WriteFloat(1, field_names[4], Throttle);
      }
      if (hasPitch) {
        output.WriteFloat(2, field_names[0], Pitch);
      }
      if (hasYaw) {
        output.WriteFloat(3, field_names[7], Yaw);
      }
      if (hasRoll) {
        output.WriteFloat(4, field_names[2], Roll);
      }
      if (hasX) {
        output.WriteFloat(5, field_names[5], X);
      }
      if (hasY) {
        output.WriteFloat(6, field_names[6], Y);
      }
      if (hasZ) {
        output.WriteFloat(7, field_names[8], Z);
      }
      if (hasSas) {
        output.WriteBool(8, field_names[3], Sas);
      }
      if (hasRcs) {
        output.WriteBool(9, field_names[1], Rcs);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasThrottle) {
          size += pb::CodedOutputStream.ComputeFloatSize(1, Throttle);
        }
        if (hasPitch) {
          size += pb::CodedOutputStream.ComputeFloatSize(2, Pitch);
        }
        if (hasYaw) {
          size += pb::CodedOutputStream.ComputeFloatSize(3, Yaw);
        }
        if (hasRoll) {
          size += pb::CodedOutputStream.ComputeFloatSize(4, Roll);
        }
        if (hasX) {
          size += pb::CodedOutputStream.ComputeFloatSize(5, X);
        }
        if (hasY) {
          size += pb::CodedOutputStream.ComputeFloatSize(6, Y);
        }
        if (hasZ) {
          size += pb::CodedOutputStream.ComputeFloatSize(7, Z);
        }
        if (hasSas) {
          size += pb::CodedOutputStream.ComputeBoolSize(8, Sas);
        }
        if (hasRcs) {
          size += pb::CodedOutputStream.ComputeBoolSize(9, Rcs);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Controls ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Controls ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Controls ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Controls ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Controls ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Controls ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Controls ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Controls ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Controls ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Controls ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Controls MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Controls prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Controls, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Controls cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Controls result;
      
      private Controls PrepareBuilder() {
        if (resultIsReadOnly) {
          Controls original = result;
          result = new Controls();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Controls MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::KRPC.Schema.Control.Controls.Descriptor; }
      }
      
      public override Controls DefaultInstanceForType {
        get { return global::KRPC.Schema.Control.Controls.DefaultInstance; }
      }
      
      public override Controls BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Controls) {
          return MergeFrom((Controls) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Controls other) {
        if (other == global::KRPC.Schema.Control.Controls.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasThrottle) {
          Throttle = other.Throttle;
        }
        if (other.HasPitch) {
          Pitch = other.Pitch;
        }
        if (other.HasYaw) {
          Yaw = other.Yaw;
        }
        if (other.HasRoll) {
          Roll = other.Roll;
        }
        if (other.HasX) {
          X = other.X;
        }
        if (other.HasY) {
          Y = other.Y;
        }
        if (other.HasZ) {
          Z = other.Z;
        }
        if (other.HasSas) {
          Sas = other.Sas;
        }
        if (other.HasRcs) {
          Rcs = other.Rcs;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_controlsFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _controlsFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 13: {
              result.hasThrottle = input.ReadFloat(ref result.throttle_);
              break;
            }
            case 21: {
              result.hasPitch = input.ReadFloat(ref result.pitch_);
              break;
            }
            case 29: {
              result.hasYaw = input.ReadFloat(ref result.yaw_);
              break;
            }
            case 37: {
              result.hasRoll = input.ReadFloat(ref result.roll_);
              break;
            }
            case 45: {
              result.hasX = input.ReadFloat(ref result.x_);
              break;
            }
            case 53: {
              result.hasY = input.ReadFloat(ref result.y_);
              break;
            }
            case 61: {
              result.hasZ = input.ReadFloat(ref result.z_);
              break;
            }
            case 64: {
              result.hasSas = input.ReadBool(ref result.sas_);
              break;
            }
            case 72: {
              result.hasRcs = input.ReadBool(ref result.rcs_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasThrottle {
        get { return result.hasThrottle; }
      }
      public float Throttle {
        get { return result.Throttle; }
        set { SetThrottle(value); }
      }
      public Builder SetThrottle(float value) {
        PrepareBuilder();
        result.hasThrottle = true;
        result.throttle_ = value;
        return this;
      }
      public Builder ClearThrottle() {
        PrepareBuilder();
        result.hasThrottle = false;
        result.throttle_ = 0F;
        return this;
      }
      
      public bool HasPitch {
        get { return result.hasPitch; }
      }
      public float Pitch {
        get { return result.Pitch; }
        set { SetPitch(value); }
      }
      public Builder SetPitch(float value) {
        PrepareBuilder();
        result.hasPitch = true;
        result.pitch_ = value;
        return this;
      }
      public Builder ClearPitch() {
        PrepareBuilder();
        result.hasPitch = false;
        result.pitch_ = 0F;
        return this;
      }
      
      public bool HasYaw {
        get { return result.hasYaw; }
      }
      public float Yaw {
        get { return result.Yaw; }
        set { SetYaw(value); }
      }
      public Builder SetYaw(float value) {
        PrepareBuilder();
        result.hasYaw = true;
        result.yaw_ = value;
        return this;
      }
      public Builder ClearYaw() {
        PrepareBuilder();
        result.hasYaw = false;
        result.yaw_ = 0F;
        return this;
      }
      
      public bool HasRoll {
        get { return result.hasRoll; }
      }
      public float Roll {
        get { return result.Roll; }
        set { SetRoll(value); }
      }
      public Builder SetRoll(float value) {
        PrepareBuilder();
        result.hasRoll = true;
        result.roll_ = value;
        return this;
      }
      public Builder ClearRoll() {
        PrepareBuilder();
        result.hasRoll = false;
        result.roll_ = 0F;
        return this;
      }
      
      public bool HasX {
        get { return result.hasX; }
      }
      public float X {
        get { return result.X; }
        set { SetX(value); }
      }
      public Builder SetX(float value) {
        PrepareBuilder();
        result.hasX = true;
        result.x_ = value;
        return this;
      }
      public Builder ClearX() {
        PrepareBuilder();
        result.hasX = false;
        result.x_ = 0F;
        return this;
      }
      
      public bool HasY {
        get { return result.hasY; }
      }
      public float Y {
        get { return result.Y; }
        set { SetY(value); }
      }
      public Builder SetY(float value) {
        PrepareBuilder();
        result.hasY = true;
        result.y_ = value;
        return this;
      }
      public Builder ClearY() {
        PrepareBuilder();
        result.hasY = false;
        result.y_ = 0F;
        return this;
      }
      
      public bool HasZ {
        get { return result.hasZ; }
      }
      public float Z {
        get { return result.Z; }
        set { SetZ(value); }
      }
      public Builder SetZ(float value) {
        PrepareBuilder();
        result.hasZ = true;
        result.z_ = value;
        return this;
      }
      public Builder ClearZ() {
        PrepareBuilder();
        result.hasZ = false;
        result.z_ = 0F;
        return this;
      }
      
      public bool HasSas {
        get { return result.hasSas; }
      }
      public bool Sas {
        get { return result.Sas; }
        set { SetSas(value); }
      }
      public Builder SetSas(bool value) {
        PrepareBuilder();
        result.hasSas = true;
        result.sas_ = value;
        return this;
      }
      public Builder ClearSas() {
        PrepareBuilder();
        result.hasSas = false;
        result.sas_ = false;
        return this;
      }
      
      public bool HasRcs {
        get { return result.hasRcs; }
      }
      public bool Rcs {
        get { return result.Rcs; }
        set { SetRcs(value); }
      }
      public Builder SetRcs(bool value) {
        PrepareBuilder();
        result.hasRcs = true;
        result.rcs_ = value;
        return this;
      }
      public Builder ClearRcs() {
        PrepareBuilder();
        result.hasRcs = false;
        result.rcs_ = false;
        return this;
      }
    }
    static Controls() {
      object.ReferenceEquals(global::KRPC.Schema.Control.Control.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class CurrentStage : pb::GeneratedMessage<CurrentStage, CurrentStage.Builder> {
    private CurrentStage() { }
    private static readonly CurrentStage defaultInstance = new CurrentStage().MakeReadOnly();
    private static readonly string[] _currentStageFieldNames = new string[] { "stage" };
    private static readonly uint[] _currentStageFieldTags = new uint[] { 8 };
    public static CurrentStage DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override CurrentStage DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override CurrentStage ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::KRPC.Schema.Control.Control.internal__static_Control_CurrentStage__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<CurrentStage, CurrentStage.Builder> InternalFieldAccessors {
      get { return global::KRPC.Schema.Control.Control.internal__static_Control_CurrentStage__FieldAccessorTable; }
    }
    
    public const int StageFieldNumber = 1;
    private bool hasStage;
    private uint stage_;
    public bool HasStage {
      get { return hasStage; }
    }
    [global::System.CLSCompliant(false)]
    public uint Stage {
      get { return stage_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasStage) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _currentStageFieldNames;
      if (hasStage) {
        output.WriteUInt32(1, field_names[0], Stage);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasStage) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, Stage);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static CurrentStage ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CurrentStage ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CurrentStage ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CurrentStage ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CurrentStage ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CurrentStage ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static CurrentStage ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static CurrentStage ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static CurrentStage ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CurrentStage ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private CurrentStage MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(CurrentStage prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<CurrentStage, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(CurrentStage cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private CurrentStage result;
      
      private CurrentStage PrepareBuilder() {
        if (resultIsReadOnly) {
          CurrentStage original = result;
          result = new CurrentStage();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override CurrentStage MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::KRPC.Schema.Control.CurrentStage.Descriptor; }
      }
      
      public override CurrentStage DefaultInstanceForType {
        get { return global::KRPC.Schema.Control.CurrentStage.DefaultInstance; }
      }
      
      public override CurrentStage BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is CurrentStage) {
          return MergeFrom((CurrentStage) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(CurrentStage other) {
        if (other == global::KRPC.Schema.Control.CurrentStage.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasStage) {
          Stage = other.Stage;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_currentStageFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _currentStageFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasStage = input.ReadUInt32(ref result.stage_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasStage {
        get { return result.hasStage; }
      }
      [global::System.CLSCompliant(false)]
      public uint Stage {
        get { return result.Stage; }
        set { SetStage(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetStage(uint value) {
        PrepareBuilder();
        result.hasStage = true;
        result.stage_ = value;
        return this;
      }
      public Builder ClearStage() {
        PrepareBuilder();
        result.hasStage = false;
        result.stage_ = 0;
        return this;
      }
    }
    static CurrentStage() {
      object.ReferenceEquals(global::KRPC.Schema.Control.Control.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
