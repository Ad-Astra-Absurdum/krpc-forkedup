using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using KRPC.Service.Attributes;
using KRPC.SpaceCenter.ExtensionMethods;
using KRPC.Utils;
using Tuple3 = KRPC.Utils.Tuple<double, double, double>;
using Tuple4 = KRPC.Utils.Tuple<double, double, double, double>;

namespace KRPC.SpaceCenter.Services.Parts
{
    /// <summary>
    /// Obtained by calling <see cref="Part.ControlSurface"/>.
    /// Provides functionality to interact with aerodynamic control surfaces.
    /// </summary>
    [KRPCClass (Service = "SpaceCenter")]
    public sealed class ControlSurface : Equatable<ControlSurface>
    {
        readonly Part part;
        readonly ModuleControlSurface controlSurface;

        internal static bool Is (Part part)
        {
            return part.InternalPart.HasModule<ModuleControlSurface> ();
        }

        internal ControlSurface (Part part)
        {
            this.part = part;
            controlSurface = part.InternalPart.Module<ModuleControlSurface> ();
            if (controlSurface == null)
                throw new ArgumentException ("Part does not have a ModuleControlSurface PartModule");
        }

        /// <summary>
        /// Check the control surfaces are equal.
        /// </summary>
        public override bool Equals (ControlSurface obj)
        {
            return part == obj.part && controlSurface == obj.controlSurface;
        }

        /// <summary>
        /// Hash the control surface.
        /// </summary>
        public override int GetHashCode ()
        {
            return part.GetHashCode () ^ controlSurface.GetHashCode ();
        }

        /// <summary>
        /// The part object for this control surface.
        /// </summary>
        [KRPCProperty]
        public Part Part {
            get { return part; }
        }

        /// <summary>
        /// Whether the control surface has pitch control enabled.
        /// </summary>
        [KRPCProperty]
        public bool PitchEnabled {
            get { return !controlSurface.ignorePitch; }
        }

        /// <summary>
        /// Whether the control surface has yaw control enabled.
        /// </summary>
        [KRPCProperty]
        public bool YawEnabled {
            get { return !controlSurface.ignoreYaw; }
        }

        /// <summary>
        /// Whether the control surface has roll control enabled.
        /// </summary>
        [KRPCProperty]
        public bool RollEnabled {
            get { return !controlSurface.ignoreRoll; }
        }

        /// <summary>
        /// Surface area of the control surface in <math>m^2</math>.
        /// </summary>
        [KRPCProperty]
        public float SurfaceArea {
            get { return controlSurface.ctrlSurfaceArea; }
        }

        /// <summary>
        /// Maximum rotation of the control surface, in the positive direction
        /// and the given reference frame.
        /// </summary>
        [KRPCMethod]
        public Tuple4 MaxPositiveRotation (ReferenceFrame referenceFrame)
        {
            return referenceFrame.RotationFromWorldSpace (WorldMaxRotation).ToTuple ();
        }

        /// <summary>
        /// Maximum rotation of the control surface, in the negative direction
        /// and the given reference frame.
        /// </summary>
        [KRPCMethod]
        public Tuple4 MaxNegativeRotation (ReferenceFrame referenceFrame)
        {
            return referenceFrame.RotationFromWorldSpace (WorldMaxRotation.Inverse ()).ToTuple ();
        }

        /// <summary>
        /// Maximum torque that can currently be generated by this control surface,
        /// if it rotates in the "positive" direction. Returns a vector of torques
        /// in the pitch, yaw and roll axes, in <math>N.m</math>
        /// </summary>
        [KRPCProperty]
        public Tuple3 PositiveTorque {
            get { return ComputeTorque (true).ToTuple (); }
        }

        /// <summary>
        /// Maximum torque that can currently be generated by this control surface,
        /// if it rotates in the "negative" direction. Returns a vector of torques
        /// in the pitch, yaw and roll axes, in <math>N.m</math>
        /// </summary>
        [KRPCProperty]
        public Tuple3 NegativeTorque {
            get { return ComputeTorque (false).ToTuple (); }
        }

        /// <summary>
        /// Current rotation of the control surface in the given reference frame.
        /// </summary>
        [KRPCMethod]
        public Tuple3 Rotation (ReferenceFrame referenceFrame)
        {
            throw new NotImplementedException ();
        }

        /// <summary>
        /// Maximum rotation of the control surface in world space in the positive direction.
        /// Take the inverse of this for the negative direction.
        /// </summary>
        Quaternion WorldMaxRotation {
            get { return Quaternion.AngleAxis (controlSurface.ctrlSurfaceRange, controlSurface.transform.rotation * Vector3.right); }
        }

        /// <summary>
        /// Velocity of the control surface through the air in world space
        /// </summary>
        Vector3d WorldVelocity {
            get { return part.InternalPart.rigidbody.GetPointVelocity (controlSurface.transform.position) + Krakensbane.GetFrameVelocityV3f (); }
        }

        /// <summary>
        /// Mach speed number of the part
        /// </summary>
        float MachNumber {
            get { return (float)part.InternalPart.machNumber; }
        }

        /// <summary>
        /// Whether the control surface is left/right, forward/back, up/down of the vessel CoM
        /// </summary>
        Vector3 CoMRelativePosition {
            get {
                var displacement = CoMDisplacement;
                float inverted = displacement.y > 0.01 ? -1 : 1;
                return new Vector3 (
                    controlSurface.ignorePitch ? 0 : inverted * (displacement.x < 0.01 ? -1 : 1),
                    controlSurface.ignoreRoll ? 0 : inverted,
                    controlSurface.ignoreYaw ? 0 : inverted * (displacement.z < 0.01 ? -1 : 1));
            }
        }

        /// <summary>
        /// Displacemet of the part CoM from the vessel CoM
        /// </summary>
        Vector3 CoMDisplacement {
            get {
                var vessel = part.InternalPart.vessel;
                var vesselCoM = vessel.findWorldCenterOfMass ();
                var partCoM = part.InternalPart.rigidbody.position;
                return vessel.transform.InverseTransformDirection (partCoM - vesselCoM);
            }
        }

        /// <summary>
        /// Max torque. In the positive direction if positive is true, otherwise in the negative direction.
        /// </summary>
        internal Vector3d ComputeTorque (bool positive)
        {
            Vector3 nVel;
            Vector3 liftVector;
            float liftDot;
            float absDot;
            controlSurface.SetupCoefficients (WorldVelocity, out nVel, out liftVector, out liftDot, out absDot);

            var partCoM = part.InternalPart.rigidbody.position;

            var maxRotation = positive ? WorldMaxRotation : WorldMaxRotation.Inverse ();
            var deflection = maxRotation * liftVector;
            liftDot = Vector3.Dot (nVel, deflection);
            absDot = Mathf.Abs (liftDot);

            var liftForce = controlSurface.GetLiftVector (deflection, liftDot, absDot, part.DynamicPressure, MachNumber) * SurfaceArea;
            var torque = part.InternalPart.vessel.GetTransform ().InverseTransformDirection (Vector3.Cross (partCoM, liftForce));
            return Vector3d.Scale (torque, CoMRelativePosition);
        }
    }
}
